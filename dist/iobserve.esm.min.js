const e={elements:"[data-iobserve]",threshold:0,thresholds:null,onEnter:null,onExit:null},t=function(e,t){let n;const o="IObserve::Initialized",s=new e(t);try{n=new CustomEvent(o,{detail:{instance:s}})}catch(e){n=document.createEvent("CustomEvent"),n.initCustomEvent(o,!1,!1,{instance:s})}window.dispatchEvent(n)},n="undefined"!=typeof window,o=n&&"IntersectionObserver"in window,s=(e,t,n,o)=>{e&&(void 0===o?void 0===n?e(t):e(t,n):e(t,n,o))},i=(e,t)=>{o&&(t._observer=new IntersectionObserver((n=>{((e,t,n)=>{e.forEach((e=>(e=>e.isIntersecting||e.intersectionRatio>0)(e)?((e,t,n,o)=>{s(n.onEnter,e,t,o)})(e.target,e,t,n):((e,t,n,o)=>{s(n.onExit,e,t,o)})(e.target,e,t,n)))})(n,e,t)}),(e=>({root:document,rootMargin:e.thresholds||e.threshold+"px"}))(e)))},r=function(t,n){const o=(t=>Object.assign({},e,t))(t);this._settings=o,this.loadingCount=0,i(o,this),this.update(n)};r.prototype={update:function(){const e=(e=>{return t=(e=>document.querySelectorAll(e.elements))(e),Array.prototype.slice.call(t);var t})(this._settings);var t,n;n=e,(e=>{e.disconnect()})(t=this._observer),((e,t)=>{t.forEach((t=>{e.observe(t)}))})(t,n)},destroy:function(){this._observer&&this._observer.disconnect(),delete this._observer,delete this._settings}},n&&((e,n)=>{if(n)if(n.length)for(let o,s=0;o=n[s];s+=1)t(e,o);else t(e,n)})(r,window.iobserveOptions);export{r as default};
